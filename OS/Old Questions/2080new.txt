#define N 5
#define LEFT (i+N-1)%N
#define RIGHT (i+1)%N
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
semaphore mutex=1
int state[N];
semaphore s[N];

void philosopher(int i) {
	while(TRUE) {
		think();
		take fork(i);
		eat();
		put fork(i);
	}
}
void take fork(int i) {
	down(&mutex);
	state[i]=HUNGRY;
	test(i);
	up(&mutex);
	down(&s[i]);
}
void put fork(int i) {
	down(&mutex);
	state[i]=THINKING;
	test(LEFT);
	test(RIGHT);
	up(&mutex);
}
void test(int i) {
	if(state==HUNGRY && state[LEFT]!=state[RIGHT]!=EATING)
		state[i]=EATING;
		up(&s[i]);
}

1. ptdc FIG
-used to perform high volume IO transfer without wasting CPU time by avoidiong byet to byte
involement

programming:
-CPU programs DMA controller by writing values into its registers
-memmory address register: specififies destination/source in memory
-byte count register: specifies amount to data
-control register: specifies IO port and tranfer direction(read/write),unit,bytes to be
transferred in one burst

transfer initiation: 
-DMA controller inistiates transfer with the IO device by issuing read request over bus to disk
controller

data transfer:
-data is transferred from disk controller to memory ybbpassing the CPU
-after transferring data, disk controller sends ACK signal to DMA controller
-DMA controller increments the memory address to use nad decrements the byte count
-this prcess continues until byte coutb reaches 0

completion notification::
-after entire block has been transferred, DMA controller generates interrupt to inform CPU
that the operation has finished 

2.
deadlock 					starvation
processes are stuck bvecause each is waiting	a process s repeatdly ignored/delayed by 
for ressourcse held by anothers			scheduler in favour of others
processes are permanently blocked and cant	process is ready/able to run but is continuosly
proceeed without external OS intervention	denied resources, not necessarily part of 
						resoruce cyle
requires all 4 conditions			cuased by greedy scheduling (SJF,non p pritoy)
affects 2/more processes			only one, though multiple can strave
proggress is not possible 			other professe continue only starved one suffers
detected using resource allocation graphs algo	hard to detect algorithmcally, observe wait time
solved by resource premption,roolback,killing	improving scheedeuling fairness(aging,RR,fair queeu)

Translation Lookaside Buffer: FIG
-associative memory cache used to accelerate transaltion of virtual(logical) address to physical
part of MMU
whe CPU generates logcail address(page number p and offest d):
-tld check: p is first searched in tlb
-tld hit: if transltaion(p->frame nubmer f) is found, TLB hit, PA is immediatly formed(f+d),
saving time needed to access main apge table
-tlb miss: if translation not found, tlb miss, system msut look up frame number in slower main
pagetable(which resides in physical memory), new translation pair is stored in TLB for future use


4. FIG
fundamental interface between apps and privileged os kernel\
programs use system call to reuqest services (file access,emmory allcaotion,process creation)
that require kernel privileges
invoked via high level API and use hardware trap mechanism to switch CPU mode from user to kernel

5. FIG
contiguous file allcoation:
each files occupies set of contiguous blocks on disk

adv:
-supports both sequential and direct access
-very fast as data blocks are physically grouped together, minimizing the no. of seeks

disadv:
-internal+external fragmenetation
-inefficeint memory utilzation
-difficult to increase file size if contigugous space is unavaiable

linekd list file allocation:
each file is considered as linked list of disk blocks
each block holds data and pointer to next disk block belonging to same file

adv:
-felxible in terms of size
-easily incersase/decrease file size
-no external fragmentation

disadv:
-no random(direct access) since accessing block requires sequentially followung the pointers
-slower
-pointers require space in disk blocks
-pointers add extra overhead on system

FAT:
table containtg one entry for each disk block and is indexed by blkock number
access FAT, read desired block entry and access taht block
random access is acheived
used by MSODS and pre NT windwos

adv:
-uses whole dis block for data
-bad disk block doesnt make successive blocks lost
-random acces but slow
-only FAT needs to be traversed

disadv:
-each disk block needs FAT entry
-FAT size may be big depending on number of FAT entries
-no. of entries can be reduced by increasing block size but it also increase internal fragmenet

i-node:
list attributes and disk address of file's blocks
to keep track of which block belongs to which file
only need sto be in memory when file is open
extra disk blocks may be reserved to store block address of large file

adv:
-supoprts random access, so fast
-no external fragmenetation

disadv:
-opinter overhead is greater than linked list
-inefficeint for small files

6. FIG pppmr
to create illusion of very large memory to users
allows prograsm taht are too alrge t fit in physical memory to run by spliiting them into pages
idelized abstracion of storage resoucrse, ensuring that not all parts of program must be in
physical memory simulatneouly for prgoram to execute

page table is data structre used to transalte virutal page number p generated by CPU into physical
frame number f.

page fram number: indicates physical location where virtual page is stored

present/abset bit(v/i bit): determiens if page is in physical memory 
=0;accesing page cause fault

protection bit: control access rights(=0read/write,1=read only) fro memory securtiy

modified bit(dirty bit): 
shwos if page has been written to since being loaded
helps os t odecide if page is to be swapped out
if set,mst be written back to disk efore replacement, else discarded
automatically set by hardware when page is written

refereced bit:trackis if page as been accessed(read/write) recently
helpign page repalce algo LFU,NRU to evict which page from memory
set by hardware on any access to apge

7.
deadlock avoidance require system to remian in safe state to gurantee deadlock wont occur

safe state:
state that guarantees existance of at least oen sequence of resource such that all rpocess
can run competl even when all of the msuddenly reuqest max resouce
total resources =10
availabe=3
process A B C need  9 4 7 resorucse
C A B is safe

unsafe state:
no safe sequence can be found, ystem cant guarantee every process will eventually finish
available = 4 but salmmest max ned is 4
may lead to deadlock but not necesasrrily a deadlocked state

8.
lock variable is software solution to solve CS problem at user level

mechanism: a shared integer variable called lock, initialized to 0(unlocked)
entry: a proces wanting to enter CR tests the lock:
	lokc=0;proces sets to 1 and enters CR
	lock=1;process enters tight loop(busy waiting) until lock is 0 (while lock!=0);
exit: upon exiting, process sets lock=-0

problm:
fails to provide mutual exclusion due to race condition
if a process reads lock=0 but is preemted before setting lock=1, 2nd process also reads
lock=0 leading both process to enter CS simultaneoulsy

9.
avoid naming conflict: allow multiple users to use same file name
logical organization: allow uesrs to group related fiels into nested sub directories
path names:support specifying files using eirther absolute/relative path name

10.
magnetic idsk consiste of:
platters: circular magnetic surface stacked on a spindle
tracks: concentric rings on surface of platter
cylinders: set of corresponding tracks across all stacked platters, used for seeking
sectors: angular segmetns of track that stroe acutal data(512 bytes), includes preamble,
the data field and ECC(error correcttion code) fied for error reovery

11.
WS is set of pages that a process is expected to use durign specifc time interval
mdeium term scheduling conecpt that helsp OS manage memory allcoation for proeeces,ensuring
that only pages that are freuqntly accessed(following locality of reference) are loaded
into main memory to optimizae memory usage

clock replacement algorithm:
apge frames are arragned in circular list like a clock
each page has a reference bit(R)
when page fault occurs, algorithm inspects the page pointed to by the hand
	R=0; page is evicted,new page is inserted and hand advances
	R=1; page is given 2nd chance, R is set to 0 and hadn advances
	process repeats until page with R=0 is found

12 a.
I node is fundamental file system structre that holds metadata about single file/directory
excludign file name and actual data content
stores details such as permission, timestamps, owner identi, pointers to file's physical
data blocks
for large files, indoes use multi level indexes(indirect,doubly indirect) to locate data blocks


12 b.
RAID (redundant array of independent disks)
ues multiple physcial disk drives to create logical unit, aiming to increase performance
and provide data redundacy to protect against drive failure
distributes data across disks to reduce impact of individual disk failures
suppoerts direct access to file blcoks and effectively addresses issue of external fragmentation

FIG
level 0: striping
-block level striipng with non redudant disk array
-best io performance acheived when data is striped acoess multiple controllers with only one
drive per controller
-high read throughput but no fault otlerance
-best write throuput since no redundant info to wrtie
-any disk failure results in data loss

level 1: mirroring
-mirrored disks with no parity
-files are striped across half the disks
-data is written to 2 places, data nad mirro disks
-best fault tolearnce
-on failure use surviving disk

level 5: striping with parity
-parioty info is distributed over all disk instead of storing in deidated disk
-parity for blocks in same rank is generated on writes, recorded in distributed lcoation
and checked on reads
-no more bottlenext as parity stress evens out by using all disks to store party info
-no possiblity of losing dat aredundancy since one idsk doesnt store all parity info
-can handle uipto single disk faliure only

level 6: striping with double parity
-blocvk level string with double distributed parity
-increases fault tolerance upto 2 drives failures in array
-each disks has 2 parity blocks stored on different disks across the array
-practical infrstructure fro maintaining high availaiblity ssytems
-large parity overhead

level 01:
-mirror of stripes, achieveing both replcaition and sharing of data between disks
-usable capacity is same as raid 1 array in which one half of drives is used to mirror toher half

level 10/1+0: combining mirrornig and striping
-combines both raid 1 and 0 by layering them in oppoiste order
-mulitoe raid 1 blocks are connected with each other to make it like raid 0
-nested/hybrid raid config
-used where huge disk performace with redundacy is required
-cost per unit memory is high since data is mirrored