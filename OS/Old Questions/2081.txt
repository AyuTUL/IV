1. FIG
logical address is addres generated by CPU while program is running, odesnt exist in main memory
segmemnt number s-index into segmenet table
offset d- displacement within that segement

physical address is actual physical location of data in memory
generated by MMU

steps for transaltion
index segement table:
	segment number s is used as index to lcoate oorect erntry in process's segment table

retrive base and limit:
	segment table contains base address and limit
	base address- starting physical address of segment in memory
	limit- legnth of segment

bounds checking:
	d is checked with limit
	if d>limit, segemetation fault occurs and traps process

physical address calculation:
	is access is valid, PA=base+offset (f+d)     


adv of segmeentation: dliss
dynamic data structure support: simplifies manging heap,stack that grow/shrink dynamically
logcial addressing: memory space is viewed logically allowing parts like code,data,stack to be
managed separately
independent compilation: segments can be compiled seaprtely,support modular programming
shared procedures/data: shring data/procesdures beteween multipel procseses
segment wise protection: each segment can be assigned it sown protection bits(egR,W,E) fro security

disadv: clep
external fragmenetation- due to being variable size,alloca and deallo memmory creates gaps
complex memory mangement- allocating,deallocating, compacting variabl esize segents is complex
performance overhead- segment table lookups and bound checkups add overhead during transaltion
limited segment seize: segemtns are bounded by system's max segemtn size                                                                      

3.
sleeping barber:
synchronization  challenge involving shared resources
one barber, one barber chair and n chairs for customers waiting in shop

if shop is empty, barber sits and falls asleep
arriving customer wakes up barber
if barber is busy, arrving customres wait in empty chair or leave if all chairs are full

solution:
solved using 3 semaphores and 1 shared varible for mutual exclusion fro maning customre
queue and synchornizing barber's sleep/wakeup status

semaphores/varaible:
-custmores: counts waiting customers exclusing the one getting hair cut. initlaized to 0
-barbers: counts barbers waiting for customers (0;/1). intialized to 0
-mutex: for mutual exclusion when accessing shared variables like waiting. initalizted to 1
-watiing: integer varable counting customes waiting in chairs

#define CHAIRS 5
typedef int semaphore;
semaphore customers=0;
semaphore barber=0;
semaphore mutex=1;
int waiting=0;

void Barber(void) {
	while(True) {
		down(customers);
		down(mutex);
		waiting--;
		up(barber);
		up(mutex);
		cut_hair();
	}
}

void Customers(void) {
	down(mutex);
	if(waiting<CHAIRS) {
		waiting++;
		up(customers);
		up(mutex);
		down(barber);
		get_haircut();
	}
	else
		up(mutex);
}


4.
microkernel:
client server OS system struture in which only absolute minimum qreuiqred code is located 
inside kernel
minimal code handlsee basic memory mgmt and inter process communicatoin code
OS functoins are divided into 2 processes:
servers- which provide services (eg file service,memor mgmt) run in user mode, outside kernel
clinets- which utilized these services
kernel's role is managing communication(message passing) between client apps and servers

adv:
smllaer,more secure as failure in one server doesnt crash entire system

disadv:
lower performance than monolithic as calling services requires IPC, more overhead

6.
only one process and execute in its CS(region accessing shared memory) at a time;mutual exclu
semaphores solves this using 2 atomic operations: down(wait/P) and up(signal/V)

P(semaphore s) {
	while(s==0);
	s--;
}

V(semaphore s) {
	s++;
}

Entry(via down):
when a process wishes to enter CS, it executes down operation
checks semaphore value, if s>0, process decrements it and proceeds into CS
if s==0,(another process is already inside CS), reuqesting process is blocked without
completing down operation, forcing to wait outside

Exit(via up):
when a process leaves CS, it executes up operation which atomically increases sempahore value
if there were process blocked wiaitng on this semaphore, one is woken up and allowed to
complete its down operation and enter CS 

Since the checking, changing, and potentially blocking/unblocking operations (down and up) 
are all performed as a single, indivisible atomic action, it is impossible for two processes 
to simultaneously pass the down check and enter the critical section, thereby 
guaranteeing mutual exclusion.

7.
deadlock:
	2 process are said to be deadlocked if one process is wiating for an event that
can only be cuased by another

conditons:
mutula exclusion: resource are either assigned to exactly one process or avaialbe
hold and wait: process curerently holding resource that were granted earlier can request fro new
no premption: resouce granted cant be forcibly taken away, msut be explicitly released
circular wait: circular chain of processes waiting for resource held by next member

deadlock avoidacne prevetns system from ever entering an unsafe state, sstate where deadlock
might occur
safe state is state if system can guarantee that there is at least one sequnce pf resource
allcoation thast allows every process to run to completion even if they all suddenly requets
their maximum resources

bankers algorthim requires processes to declare their maximum resource need in advance
When a process Pi requests a resource set R
-the system determines if R is <= avaiable resources
-if resources are available, system performs trial allocattion
-system runs safety algorithm on this hypothetical state to check is safe sequence of execution
exists
-if new state is determined to be safe, request is granted and resources are alocated
else request is denied and process is forced to wait until resources are released,  
b avoiding potentail deadlocks

if(need<=available)
	new available=available+allocation
else
	skip current process and check for others

8.	
ipc:
mechanism that allow process and threads to exchange data nad syunchorniz actions

pipes:
-simple,linear communication channels (FIFO) where a producer process writes data and 
consumer process reads it
-pipes can be named(FIFOs) and accessed via directory tree

signals:
-used by kernel to notify a process when specific event occurs(termiantion,exeception,
asynchronous events)
-signals are flags that typically carry minimal info
-can register handlers to respond to signas or execute defualt actions

shared memory:
-allows processes to share a region of memory, enabling very fast data exhange
-improves perforamce for apps that frequently access shared data
-shared memory systrsm must be paried with synchronization meachanism like locks/semaphores
to be used safely

sockets:
-for bidirectional comunication between processes on different systems(networking) but also
efficiently supports local processes
-stream sockets (TCP) provide reliable communciation
-datagram sockets (UDP) offer faster but less reliable communication

message queues(system V):
-allows processes to transmit emssagfes compposed of a type and varaible length data
which remain stored in the queeu until a receiver process is ready

9. file structures
FIG
Byte sequence-unstrucuted sequnce of bytes
-file is treated by OS as simply long continuous sequqence of bytes
-OS doesnt care/ interpret about the internal organization fo data
-any meaning must be imposed by user level programs
-used by UNIX/Windows

record sequence-sequence of fixed-length records
-file is viewed as sequence of records,each vaing same predefined length and internal structure
-read operation returens one record and write operation overwrites/appends one record
-used in old mainfram systems

tree of records:
-file is structure as a tree compose of records (not of same length)
-each records conatins a dedicated key fireld for sorting the tree
-used in large mainframe computers for commercial data processing as structure allwos for
rapid sreaching based on key
 
11. FIG
-communication methoid between CPU and IO devices
-uses unified approach where OS utilizes same address sapce to reference both regualr main
memory (RAM) and control registers and data buffers of IO devices
-control registers within IO device controller are mapped to specific address values
-when CPU executes a standard load/sstore instruction targeting one of these specific addresses,
instruction is redirected to interact with IO devices register rather than accessign RAM
-allows OS to send commands to deivce (eg telling pritner to accept data) simply by
writing to therse memory mapepd addresses
-IO devices operate aysnchornously with CPU and interrut CPU afer compeltion
-used for high speed IO devices like disks,communcaiton interfaces
-adv: implemented in high elvel languages like C, no separte protection si needed
-diadv: adds extra complexity to both hardware and OS

12.
virtual memory:
-memory mgmt technique taht creates illsuion for users of having large idealized memory space
even if actual physical memory (RAM) is limited
-breaks down prorgam's logical address space into fixed size chunks called pages which are 
mapped to physical memory frames
-not all pages must reside in physical memory simultanouly for programs to run
-if physical memory is constrained, OS sues swapping to temporrtaily move idle pages to
secondary disk and bring them back only when needed

race condition:
-occues in concurrent systems when 2/more process/threads read/write shared data and the
correctness of outcome depends critcally on the unpredicatble order in which theri operations
excute
-leads to inconsisntetn results,data corruption or loss
- to prevent them, part of code accessin the shared data(CS) must enforece mutual exclusion
ensuring only one process can execute CS ata a time