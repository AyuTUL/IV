1.
logical address is addres generated by CPU while program is running, odesnt exist in main memory
page number p-index into page table
offset d- displacement within that page

physical address is actual physical location of data in memory
generated by MMU

steps for transaltion
index segement table:
	segment number s is used as index to lcoate oorect erntry in process's segment table

retrive base and limit:
	segment table contains base address and limit
	base address- starting physical address of segment in memory
	limit- legnth of segment

bounds checking:
	d is checked with limit
	if d>limit, segemetation fault occurs and traps process

physical address calculation:
	is access is valid, PA=base+offset (f+d)     
fig

adv of segmeentation:
dynamic data structure support: simplifies manging heap,stack that grow/shrink dynamically
logcial addressing: memory space is viewed logically allowing parts like code,data,stack to be
managed separately
independent compilation: segments can be compiled seaprtely,support modular programming
shared procedures/data: shring data/procesdures beteween multipel procseses

disadv:
external fragmenetation- due to being variable size
complex memory mangement- allocating,deallocating, compacting variabl esize segents is complex
performance overhead- segment table lookups and bound checkups add overhead during transaltion
limited segment seize: segemtns are bounded by system's max segemtn size                                                                      

3.
sleeping barber:
synchronization  challenge involving shared resources
one barber, one barber chair and n chairs for customers waiting in shop

if shop is empty, barber sits and falls asleep
arriving customer wakes up barber
if barber is busy, arrving customres wait in empty chair or leave if all chairs are full

4.
microkernel:
OS system struture in which only absolute minimum qreuiqred code is located inside kernel
minimal code handlsee basic memory mgmt and inter process communicatoin code
system services like file syystems,device drives are implemetned as process called servers
that run in user mode, outside the kernel
kernel's role is managing communication(message passing) between client apps and servers

adv:
smllaer,more secure as failure in one server doesnt crash entire system

disadv:
lower performance than monolithic as calling services requires IPC, more overhead

6.
only one process and execute in its CS(region accessing shared memory) at a time;mutual exclu
semaphores solves this using 2 atomic operations: down(wait/P) and up(signal/V)

Entry(via down):
when a process wishes to enter CS, it executes down operation
checks semaphore value, if s>0, process decrements it and proceeds into CS
if s==0,(another process is already inside CS), reuqesting process is blocked without
completing down operation, forcing to wait outside

Exit(via up):
when a process leaves CS, it executes up operation which atomically increases sempahore value
if there were process blocked wiaitng on this semaphore, one is woken up and allowed to
complete its down operation and enter CS 

by ensuring that check, decrement and potential sleep are all one single indivisible atomic action,
semaphores guarantee tat fundamental flow of fimple lock variables (race condition during
check/set phase) is eliminated, ensuring mutual exclusion

deadlock:
	2 process are said to be deadlocked if one process is wiating for an event that
can only be cuased by another

conditons:
mutula exclusion: resource are either assigned to exactly one process or avaialbe
hold and wait: process holding one resource and request fro new
no premption: resouce granted cant be forcibly taken away, msut be explicitly released
circular wait: circular chain of processes waiting for resource held by next member

deadlock avoidacne prevetns system from ever entering an unsafe state, sstate where deadlock
might occur
safe state is state if system can guarantee that there is at least one sequnce pf resource
allcoation thast allows every process to run to completion even if they all suddenly requets
their maximum resources

bankers algorthim requires processes to declare their maximum resource need in advance
When a process Pi requests a resource set R
-the system determines if R is <= avaiable resources
-if resources are available, system performs trial allocattion
-system runs safety algorithm on this hypothetical state to check is safe sequence of execution
exists
-if new state is determined to be safe, request is granted else request is denied and process
is forced to wait,  avoiding potentail deadlocks

ipc:
mechanism that allow process to exchange data nad syunchorniz actions
why?
info sharing: process exchange data
comp speedup: task dived into smaller tasks run in parallel
modulairy: system functoin is sspit into smaller proess to hadnle specifc part
convenience: multiple task simultaneously

race condition:
2 processes interact and outcome depends on order in which process execute